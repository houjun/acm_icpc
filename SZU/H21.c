//经典的约瑟夫环问题
/*第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:
显而易见，第一个出列的人的编号一定是m%n-1,这个人出列后，剩下的n-1个人组成了一个新的约瑟夫环，这个约瑟夫环的第一个人在最开始的环中的编号是k=m%n（就是第一个出列的人的下一个）
k  k+1  k+2  ... n-2, n-1, 0, 1, 2, ... k-2并且从k开始报0。
事实上，可以把这个环又映射成为一个新的环：
k  --- 0
k+1 --- 1
k+2 --- 2
...  ....
k-2 -- n-1
可以看出，这就是原问题中把n替换成n-1的情况，假设我们已经求出来在这种情况下最后胜利的那个人的编号是x，那个倒推回去的那个人的编号就正好是我们要求的答案，显而易见，这个编号应该是(x+k)%n
那么如何知道n-1个人下面的这个x呢，yes，就是n-2个人情况下得到的x'倒推回去，那么如何知道n-2情况下的x'呢，当然是求n-3个人，这就是一个递归的过程
f(1) = 0（f(1)就是现在还剩下1个人，那么无论m为几，这个人总会出列，因此f(1)=0)
f(n) = (f(n-1)+m)%n
那么我们要求f(n)，就从f(1)倒推回去即可
*/
#include <stdio.h>
int main()
{
  int n, m, i, s;
  while(scanf("%d%d", &n, &m),n){
	  s=0;
	  for (i=2; i<=n; i++) 
		  s=(s+m)%i;
	  printf ("%d\n", s+1);
  }
  return 0;
}